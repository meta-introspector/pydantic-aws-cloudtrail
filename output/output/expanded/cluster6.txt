To create a CLI tool that allows you to interact with your schema, we can use Python's `argparse` module. This will help us define the commands and subcommands for our CLI.

Let's outline the structure of our CLI:

1. **Root command (`jsonschema`)**: This is the main command under which all other subcommands will be defined.
2. **Subcommands**: These will include commands to interact with different parts of your schema, such as `add`, `remove`, `list`, and `edit`.

Here's a basic implementation:

```python
import argparse

def add_node(node_type, data):
    # Logic to add a node to the schema
    print(f"Adding {node_type} with data: {data}")

def remove_node(node_type, identifier):
    # Logic to remove a node from the schema
    print(f"Removing {node_type} with identifier: {identifier}")

def list_nodes():
    # Logic to list all nodes in the schema
    print("Listing all nodes")

def edit_node(node_type, identifier, data):
    # Logic to edit an existing node in the schema
    print(f"Editing {node_type} with identifier: {identifier}, new data: {data}")

def main():
    parser = argparse.ArgumentParser(description="JSON Schema CLI")
    subparsers = parser.add_subparsers(dest="command", help="Subcommands for JSON Schema manipulation")

    # Add command
    add_parser = subparsers.add_parser("add", help="Add a node to the schema")
    add_parser.add_argument("node_type", choices=["FieldDefs", "Properties1", "Hierarchical"], help="Type of node")
    add_parser.add_argument("data", help="Data for the new node")
    add_parser.set_defaults(func=add_node)

    # Remove command
    remove_parser = subparsers.add_parser("remove", help="Remove a node from the schema")
    remove_parser.add_argument("node_type", choices=["FieldDefs", "Properties1", "Hierarchical"], help="Type of node")
    remove_parser.add_argument("identifier", help="Identifier for the node to remove")
    remove_parser.set_defaults(func=remove_node)

    # List command
    list_parser = subparsers.add_parser("list", help="List all nodes in the schema")
    list_parser.set_defaults(func=list_nodes)

    # Edit command
    edit_parser = subparsers.add_parser("edit", help="Edit an existing node in the schema")
    edit_parser.add_argument("node_type", choices=["FieldDefs", "Properties1", "Hierarchical"], help="Type of node")
    edit_parser.add_argument("identifier", help="Identifier for the node to edit")
    edit_parser.add_argument("data", help="New data for the node")
    edit_parser.set_defaults(func=edit_node)

    args = parser.parse_args()

    if hasattr(args, 'func'):
        args.func(**vars(args))
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
```

### Explanation:

1. **Argument Parsing**: The `argparse` module is used to define the CLI's structure and handle user input.
2. **Subcommands**: We use subparsers for defining different commands (`add`, `remove`, `list`, `edit`). Each subcommand has its own set of arguments.
3. **Functions**: Each command corresponds to a function that handles the logic for that specific command.

### Usage:

- To add a new node:
  ```sh
  python script.py add FieldDefs '{"key": "value"}'
  ```

- To remove a node:
  ```sh
  python script.py remove Hierarchical "identifier"
  ```

- To list all nodes:
  ```sh
  python script.py list
  ```

- To edit an existing node:
  ```sh
  python script.py edit Properties1 "identifier" '{"new_key": "new_value"}'
  ```

This is a basic implementation. You can extend it with more complex logic, error handling, and data persistence as needed.

