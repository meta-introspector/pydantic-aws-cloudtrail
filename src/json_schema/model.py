# generated by datamodel-codegen:
#   filename:  content.json
#   timestamp: 2024-12-30T13:48:31+00:00

from __future__ import annotations

from typing import Any, List, Optional
from pydantic import BaseModel

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, PositiveFloat, conint, constr
from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Field



class ContentVocabularyMetaSchema(BaseModel):
    contentEncoding: Optional[str] = None
    contentMediaType: Optional[str] = None
    contentSchema: Optional[Any] = None

#   filename:  meta-data.json
#   timestamp: 2024-12-30T13:48:31+00:00

class MetaDataVocabularyMetaSchema(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    default: Optional[Any] = None
    deprecated: Optional[bool] = False
    readOnly: Optional[bool] = False
    writeOnly: Optional[bool] = False
    examples: Optional[List] = None

class UnevaluatedApplicatorVocabularyMetaSchema(BaseModel):
    unevaluatedItems: Optional[Any] = None
    unevaluatedProperties: Optional[Any] = None

class FormatVocabularyMetaSchemaForAnnotationResults(BaseModel):
    format: Optional[str] = None


class FormatVocabularyMetaSchemaForAssertionResults(BaseModel):
    format: Optional[str] = None


class NonNegativeInteger(BaseModel):
    __root__: conint(ge=0)


class NonNegativeIntegerDefault0(BaseModel):
    __root__: NonNegativeInteger

class SimpleTypes(Enum):
    array = 'array'
    boolean = 'boolean'
    integer = 'integer'
    null = 'null'
    number = 'number'
    object = 'object'
    string = 'string'


class StringArray(BaseModel):
    __root__: List[str] = Field(..., unique_items=True)


class ValidationVocabularyMetaSchema(BaseModel):
    type: Optional[Union[SimpleTypes, List[SimpleTypes]]] = None
    const: Optional[Any] = None
    enum: Optional[List] = None
    multipleOf: Optional[PositiveFloat] = None
    maximum: Optional[float] = None
    exclusiveMaximum: Optional[float] = None
    minimum: Optional[float] = None
    exclusiveMinimum: Optional[float] = None
    maxLength: Optional[NonNegativeInteger] = None
    minLength: Optional[NonNegativeIntegerDefault0] = None
    pattern: Optional[str] = None
    maxItems: Optional[NonNegativeInteger] = None
    minItems: Optional[NonNegativeIntegerDefault0] = None
    uniqueItems: Optional[bool] = False
    maxProperties: Optional[NonNegativeInteger] = None
    minProperties: Optional[NonNegativeIntegerDefault0] = None
    required: Optional[StringArray] = None
    dependentRequired: Optional[Dict[str, StringArray]] = None

class AnchorString(BaseModel):
    __root__: constr(regex=r'^[A-Za-z_][-A-Za-z0-9._]*$')

class IriString(BaseModel):
    __root__: str

class IriReferenceString(BaseModel):
    __root__: str

class CoreVocabularyMetaSchema(BaseModel):
    field_id: Optional[IriReferenceString] = Field(None, alias='$id')
    field_schema: Optional[IriString] = Field(None, alias='$schema')
    field_ref: Optional[IriReferenceString] = Field(None, alias='$ref')
    field_anchor: Optional[AnchorString] = Field(None, alias='$anchor')
    field_dynamicRef: Optional[IriReferenceString] = Field(None, alias='$dynamicRef')
    field_dynamicAnchor: Optional[AnchorString] = Field(None, alias='$dynamicAnchor')
    field_vocabulary: Optional[Dict[str, bool]] = Field(None, alias='$vocabulary')
    field_comment: Optional[str] = Field(None, alias='$comment')
    field_defs: Optional[Dict[str, Any]] = Field(None, alias='$defs')

#   filename:  applicator.json
#   timestamp: 2024-12-30T13:48:33+00:00


class NonNegativeInteger(BaseModel):
    __root__: conint(ge=0)


class SchemaArray(BaseModel):
    __root__: List[Any] = Field(..., min_items=1)


class ApplicatorVocabularyMetaSchema(BaseModel):
    prefixItems: Optional[SchemaArray] = None
    items: Optional[Any] = None
    maxContains: Optional[NonNegativeInteger] = None
    minContains: Optional[NonNegativeInteger] = Field(
        default_factory=lambda: NonNegativeInteger.parse_obj(1)
    )
    contains: Optional[Any] = None
    additionalProperties: Optional[Any] = None
    properties: Optional[Dict[str, Any]] = {}
    patternProperties: Optional[Dict[str, Any]] = {}
    dependentSchemas: Optional[Dict[str, Any]] = {}
    propertyDependencies: Optional[Dict[str, Dict[str, Any]]] = {}
    propertyNames: Optional[Any] = None
    if_: Optional[Any] = Field(None, alias='if')
    then: Optional[Any] = None
    else_: Optional[Any] = Field(None, alias='else')
    allOf: Optional[SchemaArray] = None
    anyOf: Optional[SchemaArray] = None
    oneOf: Optional[SchemaArray] = None
    not_: Optional[Any] = Field(None, alias='not')

#   filename:  schema.json
#   timestamp: 2024-12-30T13:48:33+00:00

class Flag(BaseModel):
    valid: bool


class Model(BaseModel):
    __root__: Union[Flag, ListModel, Hierarchical] = Field(
        ...,
        description='A schema that validates the minimum requirements for validation output',
    )


class OutputUnit(BaseModel):
    valid: bool
    evaluationPath: str
    schemaLocation: AnyUrl
    instanceLocation: str
    details: Optional[OutputUnitArray] = None
    annotations: Optional[Dict[str, Any]] = None
    droppedAnnotations: Optional[Dict[str, Any]] = None
    errors: Optional[Dict[str, str]] = None


class OutputUnitArray(BaseModel):
    __root__: List[OutputUnit]


class ListModel(BaseModel):
    valid: bool
    details: OutputUnitArray


class Hierarchical(BaseModel):
    __root__: OutputUnit


Model.update_forward_refs()
OutputUnit.update_forward_refs()
